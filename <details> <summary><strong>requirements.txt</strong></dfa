"""
fetch.py  – harvest trades from Hyperliquid, EVM, Solana
"""
import os, time, functools, requests, pandas as pd, datetime as dt
from hyperliquid.info import Info

# ---------- helpers ----------
def side_flag(df, to_col, wallet):
    df["side"] = df[to_col].str.lower().eq(wallet.lower()).map(
        {True: "BUY", False: "SELL"})
    return df


@functools.lru_cache(maxsize=None)
def cg_price(symbol_id: str, ts: int) -> float:
    """Get USD price of symbol_id at UNIX ts (rounded to the day)."""
    d = time.strftime("%d-%m-%Y", time.gmtime(ts))
    url = f"https://api.coingecko.com/api/v3/coins/{symbol_id}/history?date={d}"
    data = requests.get(url, timeout=10).json()
    return data["market_data"]["current_price"]["usd"]


CGK = {            # mapping symbol ➜ coingecko-id
    "ETH": "ethereum",
    "USDC": "usd-coin",
    "SOL": "solana",
    "ARB": "arbitrum",
}

# ---------- Hyperliquid ----------
def hyperliquid_fills(addr: str) -> pd.DataFrame:
    info = Info()
    raw = info.user_fills(addr)
    df = pd.DataFrame(raw).rename(columns={"coin": "asset",
                                           "closedPnl": "pnl"})
    df["venue"] = "Hyperliquid"
    return df[["timestamp", "asset", "side", "qty", "price", "fee", "pnl", "venue"]]


# ---------- EVM via Alchemy ----------
def evm_transfers(addr: str, key: str) -> pd.DataFrame:
    url = f"https://eth-mainnet.g.alchemy.com/v2/{key}"
    body = {"jsonrpc": "2.0", "id": 1, "method": "alchemy_getAssetTransfers",
            "params": [{"fromBlock": "0x0", "toAddress": addr,
                        "category": ["erc20", "external"]}]}
    tx = requests.post(url, json=body, timeout=30).json().get("result", {}).get("transfers", [])
    if not tx:
        return pd.DataFrame()

    df = (pd.DataFrame(tx)
            .rename(columns={"asset": "asset", "value": "qty"}))
    df = side_flag(df, "to", addr)

    # P&L in USD
    prices = []
    for sym, qty, ts, sd in zip(df["asset"], df["qty"], df["metadata.blockTimestamp"], df["side"]):
        px = cg_price(CGK.get(sym, "ethereum"), int(dt.datetime.fromisoformat(ts).timestamp()))
        flow = float(qty) * px * (1 if sd == "SELL" else -1)
        prices.append(flow)
    df["pnl"] = prices
    df["price"] = px
    df["fee"] = 0
    df["venue"] = "EVM"
    return df[["metadata.blockTimestamp", "asset", "side", "qty", "price", "fee", "pnl", "venue"]]\
             .rename(columns={"metadata.blockTimestamp": "timestamp"})


# ---------- Solana via Helius ----------
def sol_tx(addr: str, key: str) -> pd.DataFrame:
    base = f"https://api.helius.xyz/v0/addresses/{addr}/transactions"
    url = f"{base}?api-key={key}&limit=100"
    rows = []

    while True:
        resp = requests.get(url, timeout=30).json()
        if isinstance(resp, list) and resp:
            rows.extend(resp)
            last_sig = resp[-1]["signature"]
            url = f"{base}?api-key={key}&before={last_sig}&limit=100"
        else:
            break

    if not rows:
        return pd.DataFrame()

    df = pd.json_normalize(rows)
    df = side_flag(df, "transferInfo.destination", addr)

    prices = []
    for sym, qty, ts, sd in zip(df["transferInfo.tokenSymbol"],
                                df["transferInfo.tokenAmount"],
                                df["timestamp"], df["side"]):
        px = cg_price(CGK.get(sym, "solana"), int(ts))
        flow = float(qty) * px * (1 if sd == "SELL" else -1)
        prices.append(flow)
    df["pnl"] = prices
    df["price"] = px
    df["fee"] = 0
    df["asset"] = df["transferInfo.tokenSymbol"]
    df["qty"] = df["transferInfo.tokenAmount"]
    df["venue"] = "Solana"
    return df[["timestamp", "asset", "side", "qty", "price", "fee", "pnl", "venue"]]
